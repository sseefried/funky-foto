{-# LANGUAGE CPP, TemplateHaskell, OverloadedStrings #-}
{-# LANGUAGE ScopedTypeVariables, TypeOperators #-}

module Handler.Images
  (
    -- Route Handlers
    getOriginalImageR
  , getBugImageR
  , getSpinnerImageR
  , getPreviewImageR
  , getInputImageR
  , getResultImageR

    -- Helpers
  , compileEffect
  , saveInputImage
  , imageHash

  ) where

-- standard libraries
import Control.Monad
import Control.Concurrent.MVar
import qualified Data.ByteString.Lazy       as BL
import qualified Data.ByteString.Lazy.Char8 as C
import Data.List

import System.Directory
import System.FilePath
import System.Cmd

import System.Plugins as Plugins
import Text.Printf

import Yesod.Helpers.Static

-- friends
import Foundation
import Settings
import Model
import BMP

-- | The dimensions to use for a scaled version of an image. If scaling is not
--   to be performed (i.e. the original image), Nothing is returned.
--
scaledDimensions :: ImageSize -> Maybe (Int, Int)
scaledDimensions Normal = Nothing
scaledDimensions Thumb  = Just (180, 180)
scaledDimensions Mobile = Just (44,  44)


-- | Return the un-altered preview image.
--
getOriginalImageR :: ImageSize -> Handler ()
getOriginalImageR size = getScaledImage size Settings.previewImage


-- | Return the "bug" image for generated images whose effect code doesn't compile.
--
getBugImageR :: ImageSize -> Handler ()
getBugImageR size = getScaledImage size Settings.bugImage


-- | Return the "spinner" image for displaying whilst images are being generated.
--
getSpinnerImageR :: Handler ()
getSpinnerImageR = sendFile "image/gif" Settings.spinnerImage


-- | Retrieve preview image resources.
--
getPreviewImageR :: ImageSize -> String -> Handler ()
getPreviewImageR size name = do
  foundation <- getYesod
  mbResult   <- runDB $ do { getBy $ UniqueEffect name }

  case mbResult of
    Nothing         -> getBugImageR size
    Just (_,effect) -> do
      let effectHash    = codeHash effect
          inputImgFile  = Settings.previewImage
          resultImgFile = imageFile (cacheDir foundation) ("preview-" ++ effectHash)

      res <- generateImage effect inputImgFile resultImgFile
      case res of
        True  -> getScaledImage size resultImgFile
        False -> getBugImageR size


-- | Retrieve an image that has been uploaded.
--
getInputImageR :: String -> Handler ()
getInputImageR imgHash = do
  foundation <- getYesod
  sendJpeg $ imageFile (cacheDir foundation) imgHash


-- | Save an input image to disk.
--
saveInputImage :: FileInfo -> Handler FilePath
saveInputImage fi = do
  foundation <- getYesod
  let contents = fileContent fi
      imgHash  = imageHash fi
      filepath = imageFile (cacheDir foundation) imgHash
  liftIO $ BL.writeFile filepath contents
  return filepath


-- | Retrieve image resource that is the result of running an effect.
--
getResultImageR :: String -> String -> Handler ()
getResultImageR name inImgHash = do
  foundation <- getYesod
  mbResult   <- runDB $ do { getBy $ UniqueEffect name }
  case mbResult of
    Nothing         -> getBugImageR Normal
    Just (_,effect) -> do
      let effectHash    = codeHash effect
          inputImgFile  = imageFile (cacheDir foundation) inImgHash
          resultImgFile = imageFile (cacheDir foundation) (effectHash ++ "-" ++ inImgHash)
      res <- generateImage effect inputImgFile resultImgFile
      case res of
        True  -> sendJpeg resultImgFile
        False -> getBugImageR Normal


-- | Retrive an image resource that is generated by running an effect. See
--   getResultImageR and getPreviewImageR.
--
generateImage :: Effect -> FilePath -> FilePath -> Handler Bool
generateImage effect inImgFile outImgFile = do
  exists <- liftIO $ doesFileExist outImgFile
  case exists of
    True  -> return True
    False -> do
      compileRes <- compileEffect effect
      case compileRes of
        (Left _)       -> return False
        (Right binary) -> do
          runEffect binary inImgFile outImgFile
          return True


-- | Retrieve a scaled version of an image. If it does not exist, generate it. Assumes
--   that the original already exists. See getBugImageR and getPreviewImageR.
--
getScaledImage :: ImageSize -> FilePath -> Handler ()
getScaledImage size originalImgFile = do
  imgFile <- maybe (return originalImgFile) (\dim -> scaleImage dim originalImgFile) (scaledDimensions size)
  sendJpeg imgFile

  where
    scaleImage :: (Int, Int) -> FilePath -> Handler FilePath
    scaleImage (w, h) inImgFile = do
      let outImgFile = (dropExtension inImgFile) ++ "-" ++  dimensions <.> "jpg"
          dimensions = (show w) ++ "x" ++ (show h)

      liftIO $ do
        exists <- doesFileExist outImgFile
        unless exists $ do
          rawSystem "convert" ["-scale", dimensions, inImgFile, outImgFile] >> return ()

      return outImgFile


-- | Helper function for sending a JPEG file. Sets the content type appropriately.
--
sendJpeg :: FilePath -> Handler ()
sendJpeg = sendFile "image/jpeg"


-- | For a given image "basename", return its location on disk.
--
imageFile :: FilePath -> String -> FilePath
imageFile cacheD imgName = cacheD </> "images" </> imgName <.> "jpg"


-- | Produce a hash string for an image file based on its contents.
--
imageHash :: FileInfo -> String
imageHash = base64md5 . fileContent

-- | Produce a hash of an effect's code string.
--
codeHash :: Effect -> String
codeHash effect = 'M' : (base64md5 $ C.pack (effectCode effect))

-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-- Helpers for compiling and running effects
--

-- | Compile the effect code. Return either the path to the compiled binary (Right) or
--   the compiler error (Left).
--
compileEffect :: Effect -> Handler (Either String FilePath)
compileEffect effect = do
  foundation <- getYesod
  let hash          = codeHash effect
      codeDir       = (cacheDir foundation) </> "code"
      effectSrcFile = codeDir </> hash <.> "hs"
      effectObjectFile = codeDir </> hash <.> "o"

  exists <- liftIO $ doesFileExist effectObjectFile
  case exists of
    True  -> return (Right effectObjectFile)
    False -> do
      liftIO $ writeFile effectSrcFile $ (effectCodeWrapper foundation) ++ (indent $ effectCode effect)
      res <- liftIO $ Plugins.make effectSrcFile ["-DMODULE_NAME=" ++ hash]
      case res of
        MakeSuccess _  objectFile -> return (Right objectFile)
        MakeFailure errors        -> return (Left (concat $ intersperse "\n" errors))

  where
    indent = concat . intersperse "\n" . map ("    " ++) . lines


-- | Obtain the CUDA lock then run the effect. Use bitmap files as the intermediate
--   image file format. Remove the bitmap files on completion.
--
runEffect :: FilePath -> FilePath -> FilePath -> Handler ()
runEffect effectObjectPath imageInJpg imageOutJpg = do
  foundation <- getYesod
  scratchDir <- liftIO $ getTemporaryDirectory

  let imageInBmp   = scratchDir </> "in"  <.> "bmp"
      imageOutBmp  = scratchDir </> "out" <.> "bmp"

  liftIO $ withMVar (cudaLock foundation) $ \() -> do
    liftIO $ jpgToBmp imageInJpg imageInBmp

    res <- Plugins.load effectObjectPath [] [] "job" -- False [imageInBmp, imageOutBmp] Nothing
    case res of
      LoadSuccess _ job -> do
        runEffectJob job (imageInBmp, imageOutBmp)
        _ <- liftIO $ bmpToJpg imageOutBmp imageOutJpg
        _ <- liftIO $ mapM removeFile [imageInBmp, imageOutBmp]
        return ()
      LoadFailure errors -> do
        _ <- liftIO $ mapM removeFile [imageInBmp, imageOutBmp]
        error (printf "Error loading '%s': %s" effectObjectPath (concat errors))


-- | Convert a JPEG file to a bitmap file.
--
jpgToBmp :: FilePath -> FilePath -> IO ()
jpgToBmp jpgFile bmpFile = rawSystem "convert" [jpgFile, bmpFile] >> return ()


-- | Convert a bitmap file to a JPEG file.
--
bmpToJpg :: FilePath -> FilePath -> IO ()
bmpToJpg bmpFile jpgFile = rawSystem "convert" [bmpFile, jpgFile] >> return ()
